# Tklr

Short for "Task Lister" but pronounced "Tickler"

A task manager that adopts TaskWarrior's urgency approach to ranking tasks but supports the entry format, component jobs, datetime parsing and recurrence features of *etm*. Requires: Python, SQLite3, DateUtil and Textual.

## Task attributes

Generally the same format as *etm* for a task entry but without the beginning item type character: the name of the task, followed by a list of @ and & delineated attributes. The attributes are separated by spaces and include the following:

- @b begin:timedelta requires @s (task status = postponed before @s - @b then available)
- @c context:str (home, shop, work, ...) alternatives specified in config.
  As with TW, specifying a context would limit the list display to tasks with that context.
- @d deleted:datetime
- @e estimate:timedelta estimated time required for completion

    a. Perhaps a "quick" command to order tasks by extent, shortest first? Someway of taking advantage of having, say 15 minutes, before a meeting?
    b. Maybe a command to limit the list display to tasks for which the estimated completion times add up to less than a specified time?
    c. Should due urgency be adjusted for the estimated time?

- @f finished:datetime
- @i importance:["N", "H", "M", "L"] numeric values in config (corresponds to next (tag) and priority in TW)
- @j job (can be used multiple times - examples below)
- @n note:str
- @p project:str
- @r rrule - requires @s (as implemented in *etm*)
- @s scheduled:datetime - a date or datetime (corresponds to due date in TW)
- @t tag:str (can be used multiple times)
- @u until:timedelta - requires @s (task status = deleted after @s + @u if pending before)

- The (unique) id for a task and its *created* and (last) *modified* dates are maintained internally.

## Task status characters and meaning

- -) Available (not waiting, finished, postponed or deleted - corresponds to pending in TW)
- *) Available and now - modified <= 1 week (modified within the last week - corresponds to current in TW)
- D) Deleted (has an @d entry or @s and @u entries with @s + @u <= now)
- F) Finished (task with an @f entry or job with an &f entry)
- P) Postponed (has @b and @s entries and @s - @b is in the future - corresponds to waiting in TW)
- W) Waiting (has one or more unfinished prerequisites - corresponds to blocked in TW)

## Tasks with component jobs

This is a simplification of the current implementation in *etm*. The need to manually enter job ids and prerequisites has been eliminated by using the position of the job in the sequence and its indentation level.

A task with @j (job) entries forms a group of related implied tasks, one for each @j entry. The prerequisites for a job, if any, are determined by the position of the @j entry in the job list and its indention level, ((number_of_spaces - 1) // 2), between the "@j" and the first, non-space character of the job. Viewed as an outline, each job depends upon (requires) all subsequently listed jobs that have a greater indention level.

Here are some simple examples of tasks with jobs. In each case "Entry" gives the multiline task as it would be entered and "jobs" gives the list of jobs (dictionaries) as generated by *Tklr*. In the dictionaries, note that "i" is job number starting from 0, "prereqs" gives the numbers of the job's unfinished prerequisites and "node" corresponds to the indention level of the job.

### jobs without prerequisites

```python
Entry:
jobs without prerequisites 
  @j Alpha 
  @j Beta 
  @j Gamma

jobs:
{'j': 'Alpha', 'node': 0, 'i': 0}
{'j': 'Beta', 'node': 0, 'i': 1}
{'j': 'Gamma', 'node': 0, 'i': 2}
```

### each job depends on the following jobs

```python
Entry:
each job depends on the following jobs  
  @j Alpha 
  @j   Beta
  @j     Gamma

jobs:
{'j': 'Alpha', 'node': 0, 'prereqs': {1, 2}, 'i': 0}
{'j': 'Beta', 'node': 1, 'prereqs': {2}, 'i': 1}
{'j': 'Gamma', 'node': 2, 'i': 2}
```

### more complex prerequisites - make a dog house

```python
Entry:
dog house @s 2025-05-15
  @j paint &c shop
  @j   sand &c shop
  @j     assemble &c shop
  @j       cut pieces &c shop
  @j          get wood &c Lowes
  @j       get hardware &c Lowes
  @j   get paint &c Lowes

jobs:
{'j': 'paint',
 'c': 'shop',
 'node': 0,
 'prereqs': {1, 2, 3, 4, 5, 6},
 'i': 0}
{'j': 'sand',
 'c': 'shop',
 'node': 1,
 'prereqs': {2, 3, 4, 5},
 'i': 1}
{'j': 'assemble',
 'c': 'shop',
 'node': 2,
 'prereqs': {3, 4, 5},
 'i': 2}
{'j': 'cut pieces',
 'c': 'shop',
 'node': 3,
 'prereqs': {4},
 'i': 3}
{'j': 'get wood',
 'c': 'Lowes',
 'node': 4,
 'i': 4}
{'j': 'get hardware',
 'c': 'Lowes',
 'node': 3,
 'i': 5}
{'j': 'get paint',
 'c': 'Lowes',
 'node': 1,
 'i': 6}
```

Note that the outline structure incorporates *backward induction* - what must be done last is considered first. When will "dog house" be done? When "paint" is completed. What has to be done before "paint"? The jobs "sand" and "get paint". And so forth. Also note the handy role of *context*.

```python
row S  name        context
 a  A  get wood     Lowes 
 b  A  get hardware Lowes 
 c  A  get paint    Lowes 
 d  B  cut pieces   shop 
 e  B  assemble     shop 
 f  B  sand         shop 
 g  B  paint        shop 
```

Note that the two available jobs, "cut pieces" and "get paint", would each be "blocking" since they are prerequisites for other jobs and would thus get the associated urgency.blocking points.

My idea is that available jobs and only available jobs should also get any relevant urgency points for "next" and "due". Furthermore, since jobs can have "&s" timedelta entries so that the scheduled (TW due) date for a job would actually be @s - &s, the urgency.due points should be calculated based on this adjusted scheduled date. Reactions?

By way of contrast, a list of jobs with the same zero indention level would be treated as a list of independent tasks since none have prerequisites.

## Dates and times

@s scheduled date or datetime.

When an `@s` entry specifies a date without a time, i.e., a date instead of a datetime, the interpretation is that the task is due sometime on that day. Specifically, it is not due until `00:00:00` on that day and not past due until `00:00:00` on the following day. The interpretation of `@b` and `@u` in this circumstance is similar. For example, if `@s 2025-04-06` is specified with `@b 3d` and `@u 2d` then the task status would change from waiting to pending at `2025-04-03 00:00:00` and, if not completed, to deleted at `2025-04-09 00:00:00`.

## configuration

```yaml
# cfg.yaml - variables and default values

task.contexts: 
  - errands 
  - home
  - shop
  - work

datetime.ambiguous.day_first: false
datetime.ambiguous.year_first: true 
# for parsing ambiguous dates

datetime.ampm: false 
# 12 hour clock if true else 24 hour clock

urgency.current: 4.0 
# now - modified <= 1 week (modified within the last week)

urgency.blocking: 8.0 
# is pending and a prerequisite for another job

urgency.age: 2.0 # coefficient for age
urgency.due: 12.0 # overdue or near due date
urgency.tag.H: 5.0 # high Priority
urgency.tag.M: 2.0 # medium Priority
urgency.tag.L: -1.0 # low Priority
urgency.tag.next: 15.0 # has a "next" tag
urgency.note: 1.0 # has a note
urgency.project: 1.0 # is assigned to a project

urgency.tags: 1.0 
# each tag (other than "next") up to a maximum of 3 
```

## urgency

As in TaskWarrior the most important urgency components are (1) having a "next" tag which gets an urgency component of 15 and (2) having a due date which gets a maximum urgency of 12. The intent seems to be to have the "next" tasks always at the top of the default (next) list with other pending tasks sorted by their urgency. This places unfinished tasks with due dates falling on or before the current date near the top of the default "next" list.  

### due

For tasks with a due date, the contribution of due to the urgency of the task is calculated as follows:

```python
def urgency_due(due: datetime) -> float:
    """
    This function calculates the urgency coefficient for a task based
    on its due datetime relative to the current datetime and returns 
    a float value between 0.2 when (due >= now + 14 days) and 1.0 when
    (due <= now - 7 days). This coefficient is then multiplied by the 
    urgency.due.coefficient (12.0) to get the due contribution to the
    overall urgency of the task.
    """
    if not due or not isinstance(due, datetime):
        return 0.0

    now = datetime.now()

    days_overdue = (now - due).total_seconds() / 86400.0
    if days_overdue >= 7.0:
        return 1.0  # < 1 wk ago
    elif days_overdue >= -14.0:
        return ((days_overdue + 14.0) * 0.8 / 21.0) + 0.2
    else:
        return 0.2  # > 2 wks
```

Note that the 14 days, the 7 days and the 0.2 - 1.0 range are hard coded in TaskWarrior - the only user configuration variable is the urgency.due.coefficient (12.0). Here is the range of values when due differs from now by an integer number of days between -7 and +14:

```python
Today: 2025-04-06
days  due date    c     12c
 -7  2025-03-30  1.00  12.00
 -6  2025-03-31  0.96  11.54
 -5  2025-04-01  0.92  11.09
 -4  2025-04-02  0.89  10.63
 -3  2025-04-03  0.85  10.17
 -2  2025-04-04  0.81   9.71
 -1  2025-04-05  0.77   9.26
  0  2025-04-06  0.73   8.80
  1  2025-04-07  0.70   8.34
  2  2025-04-08  0.66   7.89
  3  2025-04-09  0.62   7.43
  4  2025-04-10  0.58   6.97
  5  2025-04-11  0.54   6.51
  6  2025-04-12  0.50   6.06
  7  2025-04-13  0.47   5.60
  8  2025-04-14  0.43   5.14
  9  2025-04-15  0.39   4.69
 10  2025-04-16  0.35   4.23
 11  2025-04-17  0.31   3.77
 12  2025-04-18  0.28   3.31
 13  2025-04-19  0.24   2.86
 14  2025-04-20  0.20   2.40
```

### age

The contribution of age to the urgency of the task is calculated as follows:

```python
def urgency_age(created:datetime) -> float:
    """
    This function calculates the urgency coefficient for a task based
    on its age relative to the current datetime and returns a float
    value between 0.0 (when created = now) and 1.0 (when created =
    now - 365 days). This coefficient is then multiplied by the 
    urgency.age.coefficient (2.0) to get the age contribution to the
    overall urgency of the task.
    """
    if not created or not isinstance(created, datetime):
        return 0.0

    days_old = (now - created).total_seconds() / 86400.0
    if days_old >= 365.0:
        return 1.0  # > 365 days old
    elif days_old <= 0.0:
        return 0.0  # created today
    else:
        return days_old / 365.0 
```

## Views

The style for each list view is similar - a table with columns for variables and a row for each listed task. Rows are numbered (base-26) using lower case alphabetic characters where a = 0, ..., z = 25.

Pressing the key or keys corresponding to row number opens a view showing the details for that task and enables keys bound to various commands associated with the displayed task including:

- A) activate
- B) begin
- C) context
- D) delete
- E) edit
- F) finish
- I) importance
- M) refresh modified date (makes the task current for a week)
- P) project
- S) scheduled date
- T) tags
- U) until

### Next - the default view

Tasks are ordered by **urgency**. Columns include

- row number (a, b, c, ...)
- status
- name
- (context)
- (project)

The columns are sortable and the rows are filterable. The default view is a list of tasks with the following columns:

###

```
dog house @s 2025-05-15
  @l Lowes: go to Lowes &c errands 
  @j paint &c shop
  @j   sand &c shop
  @j     assemble &c shop
  @j       cut pieces &c shop
  @j         get wood &c Lowes 
  @j            :Lowes:
  @j       get hardware &c Lowes
  @j          :Lowes:
  @j   get paint &c Lowes
  @j     :Lowes:
```

Here the @l creates a label :Lowes: which must be unique, receives an id "l0" for label and being the first label. The @j job entries follow and are numbered consecutively starting from 0 unless the job string following the @j consists of a word surrounded by colons which corresponds to a label.

The jobs are indented to show their hierarchy and the context is shown in parentheses. The jobs are sorted by urgency and the labels are not shown in the list view. The label id is used to identify the label in the job entry.
