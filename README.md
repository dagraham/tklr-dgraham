<table>
  <tr>
    <td>
  <h1>tklr</h1>
      Short for "Task Lister" but pronounced "Tickler" -
      a task manager that ranks tasks by urgency and supports the entry format, component jobs, datetime parsing and recurrence features of <strong>etm</strong>.</p>
  <p>Make the most of your time!</p>
      <p></p>
    </td>
    <td style="width: 240px; vertical-align: top;">
      <img src="https://raw.githubusercontent.com/dagraham/tklr-dgraham/master/tklr_logo.avif" alt="tklr" title="Tklr" width="240px" />
      <!-- <img src="mouse_short_bkgrnd.avif" alt="tklr" title="Tklr" width="180px" /> -->
    </td>

  </tr>
</table>

Requires: Python, SQLite3, DateUtil and Textual.

ðŸ’¬ Join the conversation on the [Discussions tab](https://github.com/dagraham/tklr-dgraham/discussions)

_Preliminary and incomplete version._ This notice will be removed when the code is ready for use.

## ðŸ› ï¸ Developer Install Guide

This guide walks you through setting up a development environment for `tklr` using [`uv`](https://github.com/astral-sh/uv) and a local virtual environment.

### âœ… Step 1: Clone the repository

```bash
git clone https://github.com/dagraham/tklr-dgraham.git
cd tklr-dgraham
```

### âœ… Step 2: Create a virtual environment with `uv`

```bash
uv venv
```

This creates a `.venv/` directory inside your project.

### âœ… Step 3: Install the project in editable mode

```bash
uv pip install -e .
```

### âœ… Step 4: Use the CLI

You have two options for activating the CLI:

#### â˜‘ï¸ Option 1: Manual activation (every session)

```bash
source .venv/bin/activate
```

Then you can run:

```bash
tklr --version
tklr add "- test task @s 2025-08-01"
tklr ui
```

To deactivate:

```bash
deactivate
```

#### â˜‘ï¸ Option 2: Automatic activation with `direnv` (recommended)

##### 1. Install `direnv`

```bash
brew install direnv        # macOS
sudo apt install direnv    # Ubuntu/Debian
```

##### 2. Add the shell hook to your `~/.zshrc` or `~/.bashrc`

```sh
eval "$(direnv hook zsh)"   # or bash
```

Restart your shell or run `source ~/.zshrc`.

##### 3. In the project directory, create a `.envrc` file

```bash
echo 'export PATH="$PWD/.venv/bin:$PATH"' > .envrc
```

##### 4. Allow it

```bash
direnv allow
```

Now every time you `cd` into the project, your environment is activated automatically and, as with the manual option, test your setup with

```bash
tklr --version
tklr add "- test task @s 2025-08-01"
tklr ui
```

âœ… You're now ready to develop, test, and run `tklr` locally with full CLI and UI support.

## Dates and times

When an `@s` scheduled entry specifies a date without a time, i.e., a date instead of a datetime, the interpretation is that the task is due sometime on that day. Specifically, it is not due until `00:00:00` on that day and not past due until `00:00:00` on the following day. The interpretation of `@b` and `@u` in this circumstance is similar. For example, if `@s 2025-04-06` is specified with `@b 3d` and `@u 2d` then the task status would change from waiting to pending at `2025-04-03 00:00:00` and, if not completed, to deleted at `2025-04-09 00:00:00`.

## Recurrence

### @r and, by requirement, @s are given

When an item is specified with an `@r` entry, an `@s` entry is required and is used as the `DTSTART` entry in the recurrence rule. E.g.,

```python
* datetime repeating @s 2024-08-07 14:00 @r d &i 2
```

is serialized (stored) as

```python
  {
      "itemtype": "*",
      "subject": "datetime repeating",
      "rruleset": "DTSTART:20240807T140000\nRRULE:FREQ=DAILY;INTERVAL=2",
  }
```

**Note**: The datetimes generated by the rrulestr correspond to datetimes matching the specification of `@r` which occur **on or after** the datetime specified by `@s`. The datetime corresponding to `@s` itself will only be generated if it matches the specification of `@r`.

### @s is given but not @r

On the other hand, if an `@s` entry is specified, but `@r` is not, then the `@s` entry is stored as an `RDATE` in the recurrence rule. E.g.,

```python
* datetime only @s 2024-08-07 14:00 @e 1h30m
```

is serialized (stored) as

```python
{
  "itemtype": "*",
  "subject": "datetime only",
  "e": 5400,
  "rruleset": "RDATE:20240807T140000"
}
```

The datetime corresponding to `@s` itself is, of course, generated in this case.

### @+ is specified, with or without @r

When `@s` is specified, an `@+` entry can be used to specify one or more, comma separated datetimes. When `@r` is given, these datetimes are added to those generated by the `@r` specification. Otherwise, they are added to the datetime specified by `@s`. E.g., is a special case. It is used to specify a datetime that is relative to the current datetime. E.g.,

```python
* rdates @s 2024-08-07 14:00 @+ 2024-08-09 21:00
```

would be serialized (stored) as

```python
{
  "itemtype": "*",
  "subject": "rdates",
  "rruleset": "RDATE:20240807T140000, 20240809T210000"
}
```

This option is particularly useful for irregular recurrences such as annual doctor visits. After the initial visit, subsequent visits can simply be added to the `@+` entry of the existing event once the new appointment is made.

**Note**: Without `@r`, the `@s` datetime is included in the datetimes generated but with `@r`, it is only used to set the beginning of the recurrence and otherwise ignored.

### Timezone considerations

[[timezones.md]]

When a datetime is specified, the timezone is assumed to be the local timezone. The datetime is converted to UTC for storage in the database. When a datetime is displayed, it is converted back to the local timezone.

This would work perfectly but for _recurrence_ and _daylight savings time_. The recurrence rules are stored in UTC and the datetimes generated by the rules are also in UTC. When these datetimes are displayed, they are converted to the local timezone.

```python
- fall back @s 2024-11-01 10:00 EST  @r d &i 1 &c 4
```

```python
rruleset_str = 'DTSTART:20241101T140000\nRRULE:FREQ=DAILY;INTERVAL=1;COUNT=4'
item.entry = '- fall back @s 2024-11-01 10:00 EST  @r d &i 1 &c 4'
{
  "itemtype": "-",
  "subject": "fall back",
  "rruleset": "DTSTART:20241101T140000\nRRULE:FREQ=DAILY;INTERVAL=1;COUNT=4"
}
  Fri 2024-11-01 10:00 EDT -0400
  Sat 2024-11-02 10:00 EDT -0400
  Sun 2024-11-03 09:00 EST -0500
  Mon 2024-11-04 09:00 EST -0500
```

## urgency settings - preliminary

```yaml
task.contexts:
  - errands
  - home
  - shop
  - work

datetime.ambiguous.day_first: false
datetime.ambiguous.year_first: true
# for parsing ambiguous dates

datetime.ampm: false
# 12 hour clock if true else 24 hour clock

urgency.current: 4.0
# now - modified <= 1 week (modified within the last week)

urgency.blocking: 8.0
# is pending and a prerequisite for another job

urgency.age: 2.0 # coefficient for age
urgency.scheduled: 12.0 # past scheduled
urgency.due: 16.0 # past due or near due date
urgency.importance.next: 15.0 # next
urgency.importance.high: 6.0 # high
urgency.importance.medium: 2.0 # medium
urgency.importance.low: -2.0 # low
urgency.importance.someday: -6.0 # someday
urgency.note: 1.0 # has a note
urgency.project: 1.0 # is assigned to a project

urgency.tags: 1.0
# each tag (other than "next") up to a maximum of 3
```

The most important urgency components are (1) having a "next" tag which gets an urgency component of 15 and (2) having a due date which gets a maximum urgency of 12. The intent is to have the "next" tasks always at the top of the default (next) list with other pending tasks sorted by their urgency. This places unfinished tasks with due dates falling on or before the current date near the top of the default "next" list.

### due

For tasks with an `@d` due datetime, the contribution of due to the urgency of the task is calculated as follows:

```python
def urgency_due(due: datetime) -> float:
    """
    This function calculates the urgency coefficient for a task based
    on its due datetime relative to the current datetime and returns
    a float value between 0.2 when (due >= now + 14 days) and 1.0 when
    (due <= now - 7 days). This coefficient is then multiplied by the
    urgency.due.coefficient (12.0) to get the due contribution to the
    overall urgency of the task.
    """
    if not due or not isinstance(due, datetime):
        return 0.0

    now = datetime.now()

    days_past = (now - due).total_seconds() / 86400.0
    if days_past >= 7.0:
        return 1.0  # < 1 wk ago
    elif days_past >= -14.0:
        return ((days_past + 14.0) * 0.8 / 21.0) + 0.2
    else:
        return 0.2  # > 2 wks
```

Note that the 14 days, the 7 days and the 0.2 - 1.0 range are hard coded in TaskWarrior - the only user configuration variable is the urgency.due.coefficient (12.0). Here is the range of values when due differs from now by an integer number of days between -7 and +14:

```python
Today: 2025-04-06
days  due date    c     12c
 -7  2025-03-30  1.00  12.00
 -6  2025-03-31  0.96  11.54
 -5  2025-04-01  0.92  11.09
 -4  2025-04-02  0.89  10.63
 -3  2025-04-03  0.85  10.17
 -2  2025-04-04  0.81   9.71
 -1  2025-04-05  0.77   9.26
  0  2025-04-06  0.73   8.80
  1  2025-04-07  0.70   8.34
  2  2025-04-08  0.66   7.89
  3  2025-04-09  0.62   7.43
  4  2025-04-10  0.58   6.97
  5  2025-04-11  0.54   6.51
  6  2025-04-12  0.50   6.06
  7  2025-04-13  0.47   5.60
  8  2025-04-14  0.43   5.14
  9  2025-04-15  0.39   4.69
 10  2025-04-16  0.35   4.23
 11  2025-04-17  0.31   3.77
 12  2025-04-18  0.28   3.31
 13  2025-04-19  0.24   2.86
 14  2025-04-20  0.20   2.40
```

### age

The contribution of age to the urgency of the task is calculated as follows:

```python
def urgency_age(created:datetime) -> float:
    """
    This function calculates the urgency coefficient for a task based
    on its age relative to the current datetime and returns a float
    value between 0.0 (when created = now) and 1.0 (when created =
    now - 365 days). This coefficient is then multiplied by the
    urgency.age.coefficient (2.0) to get the age contribution to the
    overall urgency of the task.
    """
    if not created or not isinstance(created, datetime):
        return 0.0

    days_old = (now - created).total_seconds() / 86400.0
    if days_old >= 365.0:
        return 1.0  # > 365 days old
    elif days_old <= 0.0:
        return 0.0  # created today
    else:
        return days_old / 365.0
```
